<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Building My Own JSON Parser in Rust | krymancer.dev</title>
<meta name="keywords" content="">
<meta name="description" content="Introduction
I recently took on a challenge to build my own JSON parser in Rust. This project was a fantastic opportunity to dive deep into parsing techniques, which are crucial for everything from simple data formats to building compilers. You can find the full details of the challenge here and the source code in my GitHub repository.
The Challenge
The challenge was structured to incrementally build a JSON parser, starting with simple JSON objects and progressively handling more complex structures. Here&rsquo;s a step-by-step breakdown of the process.">
<meta name="author" content="">
<link rel="canonical" href="https://krymancer.dev/posts/02-cc-json-parser/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fef8779215f36ed5e7104a9f91faf747f36de6927fa5d2ad53a6cb9e4cb0bc10.css" integrity="sha256-/vh3khXzbtXnEEqfkfr3R/Nt5pJ/pdKtU6bLnkywvBA=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://krymancer.dev/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://krymancer.dev/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://krymancer.dev/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://krymancer.dev/apple-touch-icon.png">
<link rel="mask-icon" href="https://krymancer.dev/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://krymancer.dev/posts/02-cc-json-parser/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Building My Own JSON Parser in Rust" />
<meta property="og:description" content="Introduction
I recently took on a challenge to build my own JSON parser in Rust. This project was a fantastic opportunity to dive deep into parsing techniques, which are crucial for everything from simple data formats to building compilers. You can find the full details of the challenge here and the source code in my GitHub repository.
The Challenge
The challenge was structured to incrementally build a JSON parser, starting with simple JSON objects and progressively handling more complex structures. Here&rsquo;s a step-by-step breakdown of the process." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://krymancer.dev/posts/02-cc-json-parser/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-06-18T22:22:57-03:00" />
<meta property="article:modified_time" content="2024-06-18T22:22:57-03:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Building My Own JSON Parser in Rust"/>
<meta name="twitter:description" content="Introduction
I recently took on a challenge to build my own JSON parser in Rust. This project was a fantastic opportunity to dive deep into parsing techniques, which are crucial for everything from simple data formats to building compilers. You can find the full details of the challenge here and the source code in my GitHub repository.
The Challenge
The challenge was structured to incrementally build a JSON parser, starting with simple JSON objects and progressively handling more complex structures. Here&rsquo;s a step-by-step breakdown of the process."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://krymancer.dev/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Building My Own JSON Parser in Rust",
      "item": "https://krymancer.dev/posts/02-cc-json-parser/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Building My Own JSON Parser in Rust",
  "name": "Building My Own JSON Parser in Rust",
  "description": "Introduction I recently took on a challenge to build my own JSON parser in Rust. This project was a fantastic opportunity to dive deep into parsing techniques, which are crucial for everything from simple data formats to building compilers. You can find the full details of the challenge here and the source code in my GitHub repository.\nThe Challenge The challenge was structured to incrementally build a JSON parser, starting with simple JSON objects and progressively handling more complex structures. Here\u0026rsquo;s a step-by-step breakdown of the process.\n",
  "keywords": [
    
  ],
  "articleBody": "Introduction I recently took on a challenge to build my own JSON parser in Rust. This project was a fantastic opportunity to dive deep into parsing techniques, which are crucial for everything from simple data formats to building compilers. You can find the full details of the challenge here and the source code in my GitHub repository.\nThe Challenge The challenge was structured to incrementally build a JSON parser, starting with simple JSON objects and progressively handling more complex structures. Here’s a step-by-step breakdown of the process.\nStep Zero: Thinking about the problem and data structure Being honest I never really implement anything like a parser, my first idea was to count the curly braces and see if they are even (what passes the frist checks for this code challenge). But when I need to parse key-values I started to strugle. Then I took two steps backs and search about parser and remember that compiles do use tokens and parser in order to work so I started in creating a structre to handle all possible tokens in a json, and rust type system really helped me:\nenum Token { CurlyOpen, CurlyClose, SquareOpen, SquareClose, Colon, Comma, String(String), Number(f64), Bool(bool), Null, } This struct contains all the possible tokens that we will need, I took then from the json.org website, that have a really great visual representation of how parsing a json file works.\nStep One: Tokenizing the input The frist step was to get each character of the file and iterate them to create a array of tokens to be fed in a parser. Most of the tokens are straightfoward like curly braces, braces, colons and commas, but values like string, numbers, boolean and nulls required a little more work, I will not show each one because is mostly iterate throug chars making sure that the value is expected, like in string that started with \" and finishes with \", numbers can not have trailing zeros and so on. But I had some troubles that I found during testing that I find interesting and will metion latter.\nfn tokenize(input: String) -\u003e Result\u003cVec\u003cToken\u003e\u003e { // some checks and initialization ... while let Some(\u0026ch) = chars.peek() { match ch { '{' =\u003e { tokens.push(Token::CurlyOpen); chars.next(); } '}' =\u003e { tokens.push(Token::CurlyClose); chars.next(); } '[' =\u003e { tokens.push(Token::SquareOpen); chars.next(); } ']' =\u003e { tokens.push(Token::SquareClose); chars.next(); } ':' =\u003e { tokens.push(Token::Colon); chars.next(); } ',' =\u003e { tokens.push(Token::Comma); chars.next(); } '\"' =\u003e { tokens.push(Token::String(tokenize_string(\u0026mut chars)?)); } '0'..='9' | '-' =\u003e { tokens.push(Token::Number(tokenize_number(\u0026mut chars)?)); } 't' | 'f' =\u003e { tokens.push(Token::Bool(tokenize_bool(\u0026mut chars))); } 'n' =\u003e { tokenize_null(\u0026mut chars); tokens.push(Token::Null); } _ if ch.is_whitespace() =\u003e { chars.next(); } _ =\u003e return Err(anyhow!(\"Unexpected character: {}\", ch)), } } Ok(tokens) } Step Two: Parsing the tokens For parsing I had to use a struct to hold the values, using the json.org example I got all the possible values and created the following struct:\npub enum JsonValue { Object(Vec\u003c(String, JsonValue)\u003e), Array(Vec\u003cJsonValue\u003e), String(String), Number(f64), Bool(bool), Null, } With this struct I created a function that parse the a Token array. When testing I noticed that json.org has tests for depth. I didn’t know that json had a maximum depth, this is in place to prevent some attacks, we can learn more in depth about this searching, this is pretty known actually and I’m sure someone can explain way better than me so let’s keep going.\nThe function parse_tokens make sure that is only one root token and we made the check if is a object or an array also, since json only can have arrays or object as root nodes. Here I already parse the object before checking, this is not ideal but is good enouth for the frist time so I didn’t bother.\nfn parse_tokens(tokens: Vec\u003cToken\u003e) -\u003e Result\u003cJsonValue\u003e { let mut iter = tokens.iter().peekable(); let value = parse_value(\u0026mut iter, 0)?; // Check if there are any remaining tokens after the top-level value if iter.peek().is_some() { return Err(anyhow!(\"Extra tokens after top-level value\")); } match value { JsonValue::Object(_) | JsonValue::Array(_) =\u003e Ok(value), _ =\u003e Err(anyhow!( \"A JSON payload should be an object or array, not a string.\" )), } } The magic happens in the parse_value function:\nfn parse_value\u003c'a, I\u003e(tokens: \u0026mut std::iter::Peekable\u003cI\u003e, depth: usize) -\u003e Result\u003cJsonValue\u003e where I: Iterator\u003cItem = \u0026'a Token\u003e, { if depth \u003e MAX_DEPTH { return Err(anyhow!(\"Exceeded maximum nesting depth\")); } match tokens.peek() { Some(Token::CurlyOpen) =\u003e parse_object(tokens, depth), Some(Token::SquareOpen) =\u003e parse_array(tokens, depth), Some(Token::String(_)) =\u003e { if let Some(Token::String(s)) = tokens.next() { Ok(JsonValue::String(s.clone())) } else { Err(anyhow!(\"Expected a string\")) } } Some(Token::Number(_)) =\u003e { if let Some(Token::Number(n)) = tokens.next() { Ok(JsonValue::Number(*n)) } else { Err(anyhow!(\"Expected a number\")) } } Some(Token::Bool(_)) =\u003e { if let Some(Token::Bool(b)) = tokens.next() { Ok(JsonValue::Bool(*b)) } else { Err(anyhow!(\"Expected a boolean\")) } } Some(Token::Null) =\u003e { tokens.next(); // Consume the Null token Ok(JsonValue::Null) } _ =\u003e Err(anyhow!(\"Unexpected token\")), } } this basicly take care of objects, arrays, strings, numbers, booleans and null values, converting the tokens to an actuall value in rust.\nStep Three: Parsing Nested Objects and Arrays The next step was to handle JSON objects containing other objects and arrays. This required implementing recursive parsing functions, keeping in mind the depth:\nfn parse_object\u003c'a, I\u003e(tokens: \u0026mut std::iter::Peekable\u003cI\u003e, depth: usize) -\u003e Result\u003cJsonValue\u003e where I: Iterator\u003cItem = \u0026'a Token\u003e, { let mut object = Vec::new(); tokens.next(); // Consume the '{' loop { match tokens.peek() { Some(Token::CurlyClose) =\u003e { tokens.next(); // Consume the '}' break; } Some(Token::String(_)) =\u003e { if let Some(Token::String(key)) = tokens.next() { if let Some(Token::Colon) = tokens.next() { let value = parse_value(tokens, depth + 1)?; object.push((key.clone(), value)); match tokens.peek() { Some(Token::Comma) =\u003e { tokens.next(); // Consume the ',' if let Some(Token::CurlyClose) = tokens.peek() { return Err(anyhow!(\"Trailing comma in object\")); } } Some(Token::CurlyClose) =\u003e { tokens.next(); // Consume the '}' break; } _ =\u003e return Err(anyhow!(\"Expected ',' or '}' after object value\")), } } else { return Err(anyhow!(\"Expected ':' after key in object\")); } } } _ =\u003e return Err(anyhow!(\"Expected string key or '}' in object\")), } } Ok(JsonValue::Object(object)) } fn parse_array\u003c'a, I\u003e(tokens: \u0026mut std::iter::Peekable\u003cI\u003e, depth: usize) -\u003e Result\u003cJsonValue\u003e where I: Iterator\u003cItem = \u0026'a Token\u003e, { let mut array = Vec::new(); tokens.next(); // Consume the '[' loop { match tokens.peek() { Some(Token::SquareClose) =\u003e { tokens.next(); // Consume the ']' break; } Some(_) =\u003e { let value = parse_value(tokens, depth + 1)?; array.push(value); match tokens.peek() { Some(Token::Comma) =\u003e { tokens.next(); // Consume the ',' if let Some(Token::SquareClose) = tokens.peek() { return Err(anyhow!(\"Trailing comma in array\")); } } Some(Token::SquareClose) =\u003e { tokens.next(); // Consume the ']' break; } _ =\u003e return Err(anyhow!(\"Expected ',' or ']'\")), }; } _ =\u003e return Err(anyhow!(\"Expected value or ']'\")), }; } Ok(JsonValue::Array(array)) } Step Four: Testing and Validation Finally, I added my own tests to ensure the parser handles both valid and invalid JSON correctly. I also used the JSON test suite from json.org to validate the parser:\n#[cfg(test)] mod tests { use crate::parser::{parse_json, JsonValue}; #[test] fn test_invalid_path() { let path = String::from(\"invalid/path\"); let result = parse_json(path); assert!(result.is_err()); if let Err(e) = result { assert_eq!(e.to_string(), \"Failed to read File\"); } } #[test] fn test_step1_valid() { let path = String::from(\"./tests/step1/valid.json\"); let result = parse_json(path).expect(\"Error parsing JSON\"); assert_eq!(result, JsonValue::Object(vec![])); } // Additional tests for other steps... } Step Five: Testing and fixing… When testing I found two problems that needed I little work to work, strings and numbers.\nMy problem with strings was enconded characters, the frist way that I was checking for strings was to look for the end ‘\"’ putting each character in between into the strings, but I found an test that had:\n{ \"key\": \"\\\"\" } My parser broke, but when making an special case for this I found that I was not at all accouting for escaped chars so I rewrite the function to account for those:\nfn tokenize_string(chars: \u0026mut std::iter::Peekable\u003cstd::str::Chars\u003e) -\u003e Result\u003cString\u003e { let mut result = String::new(); chars.next(); // Skip opening (\") quote while let Some(\u0026ch) = chars.peek() { match ch { '\\\\' =\u003e { chars.next(); // Skip the backslash if let Some(\u0026escaped_char) = chars.peek() { match escaped_char { '\"' =\u003e result.push('\"'), '\\\\' =\u003e result.push('\\\\'), '/' =\u003e result.push('/'), 'b' =\u003e result.push('\\x08'), // Backspace rust don't like \\b in char 'f' =\u003e result.push('\\x0C'), // Form feed rust don't like \\f in char 'n' =\u003e result.push('\\n'), 'r' =\u003e result.push('\\r'), 't' =\u003e result.push('\\t'), 'u' =\u003e { let unicode_sequence = tokenize_unicode_sequence(chars)?; result += \u0026unicode_sequence; } _ =\u003e return Err(anyhow!(\"Invalid escape sequence: \\\\{}\", escaped_char)), } chars.next(); // Skip the escaped character } else { return Err(anyhow!(\"Unexpected end of input after escape character\")); } } '\"' =\u003e { chars.next(); // Skip closing (\") quote break; // Closing quote found } _ if ch.is_whitespace() \u0026\u0026 ch != ' ' =\u003e { return Err(anyhow!( \"Invalid unescaped whitespace character in string: {}\", ch )); } _ =\u003e { result.push(ch); chars.next(); } } } Ok(result) } for some reason rust didn’t like that I put '\\b' and '\\f' into the push function so I used the ascii values instead. This also acount for whitespaces in the strings, the only whitespace allowed is ' ' space itself, tabs and others must be escaped in json.\nI also found that I was not parsing unicode sequeces and they are a little different:\nfn tokenize_unicode_sequence(chars: \u0026mut std::iter::Peekable\u003cstd::str::Chars\u003e) -\u003e Result\u003cString\u003e { let mut result = String::new(); chars.next(); // Skip 'u' let mut unicode_sequence = String::new(); for _ in 0..4 { if let Some(\u0026hex_digit) = chars.peek() { if hex_digit.is_ascii_hexdigit() { unicode_sequence.push(hex_digit); chars.next(); } else { return Err(anyhow!(\"Invalid Unicode escape sequence\")); } } else { return Err(anyhow!( \"Unexpected end of input in Unicode escape sequence\" )); } } if let Ok(unicode_char) = u16::from_str_radix(\u0026unicode_sequence, 16).map(|u| char::from_u32(u as u32)) { if let Some(c) = unicode_char { result.push(c); } else { return Err(anyhow!(\"Invalid Unicode character\")); } } else { return Err(anyhow!(\"Invalid Unicode escape sequence\")); } Ok(result) } This took care of the errors that I had with strings, now we go for numbers. Frist of all, I totally forgot e AND E can be in numbers, they represent scientific notation (e=10^n) like 2e5 is the same as 2 * 10^5. Also json don’t allow leading zeros in numbers so I accounted for that. This got a simple function a lot complex but the end result (not at all perfect) was not too bad:\nfn tokenize_number(chars: \u0026mut std::iter::Peekable\u003cstd::str::Chars\u003e) -\u003e Result\u003cf64, anyhow::Error\u003e { let mut result = String::new(); let mut is_first_char = true; let mut has_dot = false; while let Some(\u0026ch) = chars.peek() { match ch { '0'..='9' =\u003e { if is_first_char \u0026\u0026 ch == '0' { chars.next(); // Consume the '0' if let Some(\u0026next_ch) = chars.peek() { match next_ch { '.' =\u003e { // Handle 0.x numbers result.push('0'); } '0'..='9' =\u003e return Err(anyhow!(\"Invalid number with leading zero\")), _ =\u003e { result.push('0'); // Just 0 break; } } } else { result.push('0'); // Just 0 break; } } else { result.push(ch); chars.next(); } } '.' =\u003e { if has_dot { return Err(anyhow!(\"Multiple decimal points in number\")); } result.push(ch); chars.next(); has_dot = true; } '-' | '+' if is_first_char =\u003e { result.push(ch); chars.next(); } 'e' | 'E' =\u003e { result.push(ch); chars.next(); // After 'e' or 'E', we should expect a digit or a sign if let Some(\u0026next_ch) = chars.peek() { if next_ch == '-' || next_ch == '+' || next_ch.is_digit(10) { result.push(next_ch); chars.next(); } else { return Err(anyhow!(\"Invalid character after exponent\")); } } else { return Err(anyhow!(\"Exponent without digits\")); } } _ =\u003e break, } is_first_char = false; } if let Some(ch) = result.chars().last() { if matches!(ch, 'e' | 'E' | '.' | '-' | '+') { return Err(anyhow!(\"Invalid number\")); } } match result.to_lowercase().parse() { Ok(number) =\u003e Ok(number), Err(..) =\u003e Err(anyhow!(\"Number is invalid\")), } } Conclusion Building a JSON parser from scratch was a challenging but rewarding experience. It provided valuable insights into parsing techniques and Rust programming. You can check out the complete source code and try the parser yourself by visiting my GitHub repository.\nI hope this post inspires you to take on similar challenges and deepen your understanding of parsing and Rust. Happy coding!\n",
  "wordCount" : "1985",
  "inLanguage": "en",
  "datePublished": "2024-06-18T22:22:57-03:00",
  "dateModified": "2024-06-18T22:22:57-03:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://krymancer.dev/posts/02-cc-json-parser/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "krymancer.dev",
    "logo": {
      "@type": "ImageObject",
      "url": "https://krymancer.dev/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://krymancer.dev/" accesskey="h" title="krymancer.dev (Alt + H)">krymancer.dev</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://krymancer.dev/archive" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/krymancer" title="Github">
                    <span>Github</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="https://x.com/joaodocodigo" title="Twitter">
                    <span>Twitter</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Building My Own JSON Parser in Rust
    </h1>
    <div class="post-meta"><span title='2024-06-18 22:22:57 -0300 -03'>June 18, 2024</span>

</div>
  </header> 
  <div class="post-content"><h3 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h3>
<p>I recently took on a challenge to build my own JSON parser in Rust. This project was a fantastic opportunity to dive deep into parsing techniques, which are crucial for everything from simple data formats to building compilers. You can find the full details of the challenge <a href="https://codingchallenges.fyi/challenges/challenge-json-parser">here</a> and the source code in my <a href="https://github.com/Krymancer/cc-json-parser">GitHub repository</a>.</p>
<h3 id="the-challenge">The Challenge<a hidden class="anchor" aria-hidden="true" href="#the-challenge">#</a></h3>
<p>The challenge was structured to incrementally build a JSON parser, starting with simple JSON objects and progressively handling more complex structures. Here&rsquo;s a step-by-step breakdown of the process.</p>
<h3 id="step-zero-thinking-about-the-problem-and-data-structure">Step Zero: Thinking about the problem and data structure<a hidden class="anchor" aria-hidden="true" href="#step-zero-thinking-about-the-problem-and-data-structure">#</a></h3>
<p>Being honest I never really implement anything like a parser, my first idea was to count the curly braces and see if they are even (what passes the frist checks for this code challenge). But when I need to parse key-values I started to strugle. Then I took two steps backs and search about parser and remember that compiles do use tokens and parser in order to work so I started in creating a structre to handle all possible tokens in a json, and rust type system really helped me:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Token</span> {
</span></span><span style="display:flex;"><span>    CurlyOpen,
</span></span><span style="display:flex;"><span>    CurlyClose,
</span></span><span style="display:flex;"><span>SquareOpen,
</span></span><span style="display:flex;"><span>    SquareClose,
</span></span><span style="display:flex;"><span>    Colon,
</span></span><span style="display:flex;"><span>    Comma,
</span></span><span style="display:flex;"><span>    String(String),
</span></span><span style="display:flex;"><span>    Number(<span style="color:#66d9ef">f64</span>),
</span></span><span style="display:flex;"><span>    Bool(<span style="color:#66d9ef">bool</span>),
</span></span><span style="display:flex;"><span>    Null,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This struct contains all the possible tokens that we will need, I took then from the <a href="https://www.json.org/json-en.html">json.org</a> website, that have a really great visual representation of how parsing a json file works.</p>
<h3 id="step-one-tokenizing-the-input">Step One: Tokenizing the input<a hidden class="anchor" aria-hidden="true" href="#step-one-tokenizing-the-input">#</a></h3>
<p>The frist step was to get each character of the file and iterate them to create a array of tokens to be fed in a parser. Most of the tokens are straightfoward like curly braces, braces, colons and commas, but values like string, numbers, boolean and nulls required a little more work, I will not show each one because is mostly iterate throug chars making sure that the value is expected, like in string that started with <code>&quot;</code> and finishes with <code>&quot;</code>, numbers can not have trailing zeros and so on. But I had some troubles that I found during testing that I find interesting and will metion latter.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">tokenize</span>(input: String) -&gt; Result<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>Token<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// some checks and initialization ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some(<span style="color:#f92672">&amp;</span>ch) <span style="color:#f92672">=</span> chars.peek() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> ch {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;{&#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                tokens.push(Token::CurlyOpen);
</span></span><span style="display:flex;"><span>                chars.next();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;}&#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                tokens.push(Token::CurlyClose);
</span></span><span style="display:flex;"><span>                chars.next();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;[&#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                tokens.push(Token::SquareOpen);
</span></span><span style="display:flex;"><span>                chars.next();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;]&#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                tokens.push(Token::SquareClose);
</span></span><span style="display:flex;"><span>                chars.next();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;:&#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                tokens.push(Token::Colon);
</span></span><span style="display:flex;"><span>                chars.next();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;,&#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                tokens.push(Token::Comma);
</span></span><span style="display:flex;"><span>                chars.next();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;&#34;&#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                tokens.push(Token::String(tokenize_string(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> chars)<span style="color:#f92672">?</span>));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;0&#39;</span><span style="color:#f92672">..=</span><span style="color:#e6db74">&#39;9&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;-&#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                tokens.push(Token::Number(tokenize_number(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> chars)<span style="color:#f92672">?</span>));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;t&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;f&#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                tokens.push(Token::Bool(tokenize_bool(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> chars)));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;n&#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                tokenize_null(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> chars);
</span></span><span style="display:flex;"><span>                tokens.push(Token::Null);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            _ <span style="color:#66d9ef">if</span> ch.is_whitespace() <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                chars.next();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            _ <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(anyhow!(<span style="color:#e6db74">&#34;Unexpected character: {}&#34;</span>, ch)),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Ok(tokens)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="step-two-parsing-the-tokens">Step Two: Parsing the tokens<a hidden class="anchor" aria-hidden="true" href="#step-two-parsing-the-tokens">#</a></h3>
<p>For parsing I had to use a struct to hold the values, using the json.org example I got all the possible values and created the following struct:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">JsonValue</span> {
</span></span><span style="display:flex;"><span>    Object(Vec<span style="color:#f92672">&lt;</span>(String, JsonValue)<span style="color:#f92672">&gt;</span>),
</span></span><span style="display:flex;"><span>    Array(Vec<span style="color:#f92672">&lt;</span>JsonValue<span style="color:#f92672">&gt;</span>),
</span></span><span style="display:flex;"><span>    String(String),
</span></span><span style="display:flex;"><span>    Number(<span style="color:#66d9ef">f64</span>),
</span></span><span style="display:flex;"><span>    Bool(<span style="color:#66d9ef">bool</span>),
</span></span><span style="display:flex;"><span>    Null,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>With this struct I created a function that parse the a Token array. When testing I noticed that json.org has tests for depth. I didn&rsquo;t know that json had a maximum depth, this is in place to prevent some attacks, we can learn more in depth about this searching, this is pretty known actually and I&rsquo;m sure someone can explain way better than me so let&rsquo;s keep going.</p>
<p>The function <code>parse_tokens</code> make sure that is only one root token and we made the check if is a object or an array also, since json only can have arrays or object as root nodes.
Here I already parse the object before checking, this is not ideal but is good enouth for the frist time so I didn&rsquo;t bother.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">parse_tokens</span>(tokens: Vec<span style="color:#f92672">&lt;</span>Token<span style="color:#f92672">&gt;</span>) -&gt; Result<span style="color:#f92672">&lt;</span>JsonValue<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> iter <span style="color:#f92672">=</span> tokens.iter().peekable();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> value <span style="color:#f92672">=</span> parse_value(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> iter, <span style="color:#ae81ff">0</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Check if there are any remaining tokens after the top-level value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> iter.peek().is_some() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Err(anyhow!(<span style="color:#e6db74">&#34;Extra tokens after top-level value&#34;</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> value {
</span></span><span style="display:flex;"><span>        JsonValue::Object(_) <span style="color:#f92672">|</span> JsonValue::Array(_) <span style="color:#f92672">=&gt;</span> Ok(value),
</span></span><span style="display:flex;"><span>        _ <span style="color:#f92672">=&gt;</span> Err(anyhow!(
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;A JSON payload should be an object or array, not a string.&#34;</span>
</span></span><span style="display:flex;"><span>        )),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The magic happens in the <code>parse_value</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">parse_value</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span>, I<span style="color:#f92672">&gt;</span>(tokens: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> std::iter::Peekable<span style="color:#f92672">&lt;</span>I<span style="color:#f92672">&gt;</span>, depth: <span style="color:#66d9ef">usize</span>) -&gt; Result<span style="color:#f92672">&lt;</span>JsonValue<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    I: Iterator<span style="color:#f92672">&lt;</span>Item <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">&#39;a</span> Token<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> depth <span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">MAX_DEPTH</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Err(anyhow!(<span style="color:#e6db74">&#34;Exceeded maximum nesting depth&#34;</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> tokens.peek() {
</span></span><span style="display:flex;"><span>        Some(Token::CurlyOpen) <span style="color:#f92672">=&gt;</span> parse_object(tokens, depth),
</span></span><span style="display:flex;"><span>        Some(Token::SquareOpen) <span style="color:#f92672">=&gt;</span> parse_array(tokens, depth),
</span></span><span style="display:flex;"><span>        Some(Token::String(_)) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(Token::String(s)) <span style="color:#f92672">=</span> tokens.next() {
</span></span><span style="display:flex;"><span>                Ok(JsonValue::String(s.clone()))
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                Err(anyhow!(<span style="color:#e6db74">&#34;Expected a string&#34;</span>))
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        Some(Token::Number(_)) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(Token::Number(n)) <span style="color:#f92672">=</span> tokens.next() {
</span></span><span style="display:flex;"><span>                Ok(JsonValue::Number(<span style="color:#f92672">*</span>n))
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                Err(anyhow!(<span style="color:#e6db74">&#34;Expected a number&#34;</span>))
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        Some(Token::Bool(_)) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(Token::Bool(b)) <span style="color:#f92672">=</span> tokens.next() {
</span></span><span style="display:flex;"><span>                Ok(JsonValue::Bool(<span style="color:#f92672">*</span>b))
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                Err(anyhow!(<span style="color:#e6db74">&#34;Expected a boolean&#34;</span>))
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        Some(Token::Null) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            tokens.next(); <span style="color:#75715e">// Consume the Null token
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            Ok(JsonValue::Null)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        _ <span style="color:#f92672">=&gt;</span> Err(anyhow!(<span style="color:#e6db74">&#34;Unexpected token&#34;</span>)),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>this basicly take care of objects, arrays, strings, numbers, booleans and null values, converting the tokens to an actuall value in rust.</p>
<h3 id="step-three-parsing-nested-objects-and-arrays">Step Three: Parsing Nested Objects and Arrays<a hidden class="anchor" aria-hidden="true" href="#step-three-parsing-nested-objects-and-arrays">#</a></h3>
<p>The next step was to handle JSON objects containing other objects and arrays. This required implementing recursive parsing functions, keeping in mind the depth:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">parse_object</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span>, I<span style="color:#f92672">&gt;</span>(tokens: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> std::iter::Peekable<span style="color:#f92672">&lt;</span>I<span style="color:#f92672">&gt;</span>, depth: <span style="color:#66d9ef">usize</span>) -&gt; Result<span style="color:#f92672">&lt;</span>JsonValue<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    I: Iterator<span style="color:#f92672">&lt;</span>Item <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">&#39;a</span> Token<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> object <span style="color:#f92672">=</span> Vec::new();
</span></span><span style="display:flex;"><span>    tokens.next(); <span style="color:#75715e">// Consume the &#39;{&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> tokens.peek() {
</span></span><span style="display:flex;"><span>            Some(Token::CurlyClose) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                tokens.next(); <span style="color:#75715e">// Consume the &#39;}&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            Some(Token::String(_)) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(Token::String(key)) <span style="color:#f92672">=</span> tokens.next() {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(Token::Colon) <span style="color:#f92672">=</span> tokens.next() {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">let</span> value <span style="color:#f92672">=</span> parse_value(tokens, depth <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>                        object.push((key.clone(), value));
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">match</span> tokens.peek() {
</span></span><span style="display:flex;"><span>                            Some(Token::Comma) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                                tokens.next(); <span style="color:#75715e">// Consume the &#39;,&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(Token::CurlyClose) <span style="color:#f92672">=</span> tokens.peek() {
</span></span><span style="display:flex;"><span>                                    <span style="color:#66d9ef">return</span> Err(anyhow!(<span style="color:#e6db74">&#34;Trailing comma in object&#34;</span>));
</span></span><span style="display:flex;"><span>                                }
</span></span><span style="display:flex;"><span>                            }
</span></span><span style="display:flex;"><span>                            Some(Token::CurlyClose) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                                tokens.next(); <span style="color:#75715e">// Consume the &#39;}&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                            }
</span></span><span style="display:flex;"><span>                            _ <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(anyhow!(<span style="color:#e6db74">&#34;Expected &#39;,&#39; or &#39;}&#39; after object value&#34;</span>)),
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">return</span> Err(anyhow!(<span style="color:#e6db74">&#34;Expected &#39;:&#39; after key in object&#34;</span>));
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            _ <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(anyhow!(<span style="color:#e6db74">&#34;Expected string key or &#39;}&#39; in object&#34;</span>)),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Ok(JsonValue::Object(object))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">parse_array</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span>, I<span style="color:#f92672">&gt;</span>(tokens: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> std::iter::Peekable<span style="color:#f92672">&lt;</span>I<span style="color:#f92672">&gt;</span>, depth: <span style="color:#66d9ef">usize</span>) -&gt; Result<span style="color:#f92672">&lt;</span>JsonValue<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    I: Iterator<span style="color:#f92672">&lt;</span>Item <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">&#39;a</span> Token<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> array <span style="color:#f92672">=</span> Vec::new();
</span></span><span style="display:flex;"><span>    tokens.next(); <span style="color:#75715e">// Consume the &#39;[&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> tokens.peek() {
</span></span><span style="display:flex;"><span>            Some(Token::SquareClose) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                tokens.next(); <span style="color:#75715e">// Consume the &#39;]&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            Some(_) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> value <span style="color:#f92672">=</span> parse_value(tokens, depth <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>                array.push(value);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">match</span> tokens.peek() {
</span></span><span style="display:flex;"><span>                    Some(Token::Comma) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                        tokens.next(); <span style="color:#75715e">// Consume the &#39;,&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(Token::SquareClose) <span style="color:#f92672">=</span> tokens.peek() {
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">return</span> Err(anyhow!(<span style="color:#e6db74">&#34;Trailing comma in array&#34;</span>));
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    Some(Token::SquareClose) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                        tokens.next(); <span style="color:#75715e">// Consume the &#39;]&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    _ <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(anyhow!(<span style="color:#e6db74">&#34;Expected &#39;,&#39; or &#39;]&#39;&#34;</span>)),
</span></span><span style="display:flex;"><span>                };
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            _ <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(anyhow!(<span style="color:#e6db74">&#34;Expected value or &#39;]&#39;&#34;</span>)),
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Ok(JsonValue::Array(array))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="step-four-testing-and-validation">Step Four: Testing and Validation<a hidden class="anchor" aria-hidden="true" href="#step-four-testing-and-validation">#</a></h3>
<p>Finally, I added my own tests to ensure the parser handles both valid and invalid JSON correctly. I also used the JSON test suite from json.org to validate the parser:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[cfg(test)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">mod</span> tests {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">use</span> <span style="color:#66d9ef">crate</span>::parser::{parse_json, JsonValue};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#[test]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test_invalid_path</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> path <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;invalid/path&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> parse_json(path);
</span></span><span style="display:flex;"><span>        assert!(result.is_err());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Err(e) <span style="color:#f92672">=</span> result {
</span></span><span style="display:flex;"><span>            assert_eq!(e.to_string(), <span style="color:#e6db74">&#34;Failed to read File&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#[test]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test_step1_valid</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> path <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;./tests/step1/valid.json&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> parse_json(path).expect(<span style="color:#e6db74">&#34;Error parsing JSON&#34;</span>);
</span></span><span style="display:flex;"><span>        assert_eq!(result, JsonValue::Object(vec![]));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Additional tests for other steps...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="step-five-testing-and-fixing">Step Five: Testing and fixing&hellip;<a hidden class="anchor" aria-hidden="true" href="#step-five-testing-and-fixing">#</a></h3>
<p>When testing I found two problems that needed I little work to work, strings and numbers.</p>
<p>My problem with strings was enconded characters, the frist way that I was checking for strings was to look for the end &lsquo;&quot;&rsquo; putting each character in between into the strings, but I found an test that had:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;key&#34;</span>: <span style="color:#e6db74">&#34;\&#34;&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>My parser broke, but when making an special case for this I found that I was not at all accouting for escaped chars so I rewrite the function to account for those:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">tokenize_string</span>(chars: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> std::iter::Peekable<span style="color:#f92672">&lt;</span>std::<span style="color:#66d9ef">str</span>::Chars<span style="color:#f92672">&gt;</span>) -&gt; Result<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> result <span style="color:#f92672">=</span> String::new();
</span></span><span style="display:flex;"><span>    chars.next(); <span style="color:#75715e">// Skip opening (&#34;) quote
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some(<span style="color:#f92672">&amp;</span>ch) <span style="color:#f92672">=</span> chars.peek() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> ch {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;\\&#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                chars.next(); <span style="color:#75715e">// Skip the backslash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(<span style="color:#f92672">&amp;</span>escaped_char) <span style="color:#f92672">=</span> chars.peek() {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">match</span> escaped_char {
</span></span><span style="display:flex;"><span>                        <span style="color:#e6db74">&#39;&#34;&#39;</span> <span style="color:#f92672">=&gt;</span> result.push(<span style="color:#e6db74">&#39;&#34;&#39;</span>),
</span></span><span style="display:flex;"><span>                        <span style="color:#e6db74">&#39;\\&#39;</span> <span style="color:#f92672">=&gt;</span> result.push(<span style="color:#e6db74">&#39;\\&#39;</span>),
</span></span><span style="display:flex;"><span>                        <span style="color:#e6db74">&#39;/&#39;</span> <span style="color:#f92672">=&gt;</span> result.push(<span style="color:#e6db74">&#39;/&#39;</span>),
</span></span><span style="display:flex;"><span>                        <span style="color:#e6db74">&#39;b&#39;</span> <span style="color:#f92672">=&gt;</span> result.push(<span style="color:#e6db74">&#39;\x08&#39;</span>), <span style="color:#75715e">// Backspace rust don&#39;t like \b in char
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                        <span style="color:#e6db74">&#39;f&#39;</span> <span style="color:#f92672">=&gt;</span> result.push(<span style="color:#e6db74">&#39;\x0C&#39;</span>), <span style="color:#75715e">// Form feed rust don&#39;t like \f in char
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                        <span style="color:#e6db74">&#39;n&#39;</span> <span style="color:#f92672">=&gt;</span> result.push(<span style="color:#e6db74">&#39;\n&#39;</span>),
</span></span><span style="display:flex;"><span>                        <span style="color:#e6db74">&#39;r&#39;</span> <span style="color:#f92672">=&gt;</span> result.push(<span style="color:#e6db74">&#39;\r&#39;</span>),
</span></span><span style="display:flex;"><span>                        <span style="color:#e6db74">&#39;t&#39;</span> <span style="color:#f92672">=&gt;</span> result.push(<span style="color:#e6db74">&#39;\t&#39;</span>),
</span></span><span style="display:flex;"><span>                        <span style="color:#e6db74">&#39;u&#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">let</span> unicode_sequence <span style="color:#f92672">=</span> tokenize_unicode_sequence(chars)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>                            result <span style="color:#f92672">+=</span> <span style="color:#f92672">&amp;</span>unicode_sequence;
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                        _ <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(anyhow!(<span style="color:#e6db74">&#34;Invalid escape sequence: </span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">{}&#34;</span>, escaped_char)),
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    chars.next(); <span style="color:#75715e">// Skip the escaped character
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> Err(anyhow!(<span style="color:#e6db74">&#34;Unexpected end of input after escape character&#34;</span>));
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;&#34;&#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                chars.next(); <span style="color:#75715e">// Skip closing (&#34;) quote
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">break</span>; <span style="color:#75715e">// Closing quote found
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>            _ <span style="color:#66d9ef">if</span> ch.is_whitespace() <span style="color:#f92672">&amp;&amp;</span> ch <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> Err(anyhow!(
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;Invalid unescaped whitespace character in string: {}&#34;</span>,
</span></span><span style="display:flex;"><span>                    ch
</span></span><span style="display:flex;"><span>                ));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            _ <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                result.push(ch);
</span></span><span style="display:flex;"><span>                chars.next();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Ok(result)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>for some reason rust didn&rsquo;t like that I put <code>'\b'</code> and <code>'\f'</code> into the push function so I used the ascii values instead. This also acount for whitespaces in the strings, the only whitespace allowed is <code>' '</code> space itself, tabs and others must be escaped in json.</p>
<p>I also found that I was not parsing unicode sequeces and they are a little different:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">tokenize_unicode_sequence</span>(chars: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> std::iter::Peekable<span style="color:#f92672">&lt;</span>std::<span style="color:#66d9ef">str</span>::Chars<span style="color:#f92672">&gt;</span>) -&gt; Result<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> result <span style="color:#f92672">=</span> String::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    chars.next(); <span style="color:#75715e">// Skip &#39;u&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> unicode_sequence <span style="color:#f92672">=</span> String::new();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> _ <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">4</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(<span style="color:#f92672">&amp;</span>hex_digit) <span style="color:#f92672">=</span> chars.peek() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> hex_digit.is_ascii_hexdigit() {
</span></span><span style="display:flex;"><span>                unicode_sequence.push(hex_digit);
</span></span><span style="display:flex;"><span>                chars.next();
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> Err(anyhow!(<span style="color:#e6db74">&#34;Invalid Unicode escape sequence&#34;</span>));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Err(anyhow!(
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;Unexpected end of input in Unicode escape sequence&#34;</span>
</span></span><span style="display:flex;"><span>            ));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Ok(unicode_char) <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">u16</span>::from_str_radix(<span style="color:#f92672">&amp;</span>unicode_sequence, <span style="color:#ae81ff">16</span>).map(<span style="color:#f92672">|</span>u<span style="color:#f92672">|</span> <span style="color:#66d9ef">char</span>::from_u32(u <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u32</span>))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(c) <span style="color:#f92672">=</span> unicode_char {
</span></span><span style="display:flex;"><span>            result.push(c);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Err(anyhow!(<span style="color:#e6db74">&#34;Invalid Unicode character&#34;</span>));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Err(anyhow!(<span style="color:#e6db74">&#34;Invalid Unicode escape sequence&#34;</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Ok(result)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This took care of the errors that I had with strings, now we go for numbers. Frist of all, I totally forgot <code>e</code> AND <code>E</code> can be in numbers, they represent scientific notation (e=10^n) like 2e5 is the same as 2 * 10^5. Also json don&rsquo;t allow leading zeros in numbers so I accounted for that. This got a simple function a lot complex but the end result (not at all perfect) was not too bad:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">tokenize_number</span>(chars: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> std::iter::Peekable<span style="color:#f92672">&lt;</span>std::<span style="color:#66d9ef">str</span>::Chars<span style="color:#f92672">&gt;</span>) -&gt; Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f64</span>, anyhow::Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> result <span style="color:#f92672">=</span> String::new();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> is_first_char <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> has_dot <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some(<span style="color:#f92672">&amp;</span>ch) <span style="color:#f92672">=</span> chars.peek() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> ch {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;0&#39;</span><span style="color:#f92672">..=</span><span style="color:#e6db74">&#39;9&#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> is_first_char <span style="color:#f92672">&amp;&amp;</span> ch <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0&#39;</span> {
</span></span><span style="display:flex;"><span>                    chars.next(); <span style="color:#75715e">// Consume the &#39;0&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(<span style="color:#f92672">&amp;</span>next_ch) <span style="color:#f92672">=</span> chars.peek() {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">match</span> next_ch {
</span></span><span style="display:flex;"><span>                            <span style="color:#e6db74">&#39;.&#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                                <span style="color:#75715e">// Handle 0.x numbers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                result.push(<span style="color:#e6db74">&#39;0&#39;</span>);
</span></span><span style="display:flex;"><span>                            }
</span></span><span style="display:flex;"><span>                            <span style="color:#e6db74">&#39;0&#39;</span><span style="color:#f92672">..=</span><span style="color:#e6db74">&#39;9&#39;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(anyhow!(<span style="color:#e6db74">&#34;Invalid number with leading zero&#34;</span>)),
</span></span><span style="display:flex;"><span>                            _ <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                                result.push(<span style="color:#e6db74">&#39;0&#39;</span>); <span style="color:#75715e">// Just 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                            }
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                        result.push(<span style="color:#e6db74">&#39;0&#39;</span>); <span style="color:#75715e">// Just 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    result.push(ch);
</span></span><span style="display:flex;"><span>                    chars.next();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;.&#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> has_dot {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> Err(anyhow!(<span style="color:#e6db74">&#34;Multiple decimal points in number&#34;</span>));
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                result.push(ch);
</span></span><span style="display:flex;"><span>                chars.next();
</span></span><span style="display:flex;"><span>                has_dot <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;-&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#66d9ef">if</span> is_first_char <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                result.push(ch);
</span></span><span style="display:flex;"><span>                chars.next();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;e&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;E&#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                result.push(ch);
</span></span><span style="display:flex;"><span>                chars.next();
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// After &#39;e&#39; or &#39;E&#39;, we should expect a digit or a sign
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(<span style="color:#f92672">&amp;</span>next_ch) <span style="color:#f92672">=</span> chars.peek() {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> next_ch <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;-&#39;</span> <span style="color:#f92672">||</span> next_ch <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#f92672">||</span> next_ch.is_digit(<span style="color:#ae81ff">10</span>) {
</span></span><span style="display:flex;"><span>                        result.push(next_ch);
</span></span><span style="display:flex;"><span>                        chars.next();
</span></span><span style="display:flex;"><span>                    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">return</span> Err(anyhow!(<span style="color:#e6db74">&#34;Invalid character after exponent&#34;</span>));
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> Err(anyhow!(<span style="color:#e6db74">&#34;Exponent without digits&#34;</span>));
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            _ <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">break</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        is_first_char <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(ch) <span style="color:#f92672">=</span> result.chars().last() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> matches!(ch, <span style="color:#e6db74">&#39;e&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;E&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;.&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;-&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;+&#39;</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Err(anyhow!(<span style="color:#e6db74">&#34;Invalid number&#34;</span>));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> result.to_lowercase().parse() {
</span></span><span style="display:flex;"><span>        Ok(number) <span style="color:#f92672">=&gt;</span> Ok(number),
</span></span><span style="display:flex;"><span>        Err(<span style="color:#f92672">..</span>) <span style="color:#f92672">=&gt;</span> Err(anyhow!(<span style="color:#e6db74">&#34;Number is invalid&#34;</span>)),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h3>
<p>Building a JSON parser from scratch was a challenging but rewarding experience. It provided valuable insights into parsing techniques and Rust programming. You can check out the complete source code and try the parser yourself by visiting my <a href="https://github.com/Krymancer/cc-json-parser">GitHub repository</a>.</p>
<p>I hope this post inspires you to take on similar challenges and deepen your understanding of parsing and Rust. Happy coding!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://krymancer.dev/">krymancer.dev</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
